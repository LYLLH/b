第一章 JavaScript简介

JavaScript是一种专为网页交互而设计的脚本语言，完整的JavaScript实现由以下三部分组成：

1.核心（ECMAScript）
由ECMA-262定义，提供核心语言功能。
ECMA-262规定：语法、类型、语句、关键字、保留字、操作符、对象。

2.文档对象模型（DOM）
提供访问和操作网页内容的方法和接口。

3.浏览器对象模型（BOM）
提供一浏览器交互的方法和接口。

第二章 在HTML中使用JavaScript

1.<script>元素

向HTML页面中插入JavaScript的主要方法。使用<script>元素的方式有两种：直接在页面中嵌入JavaScript代码和包含外部JavaScript文件。

在使用<script>嵌入JavaScript代码时，不要在代码中的任何地方出现"</script>"字符串，可通过转义字符解决"<\ /script>"。

要通过<script>元素来包含外部JavaScript文件，需要src属性，例如：
<script type="text/javascript" src="example.js"></script>

延迟脚本：
defer属性（用于改变处理脚本的行为，只适用于外部脚本文件，并告诉浏览器立即下载文件，但延迟执行）

异步脚本：
async属性（与defer属性类似，但并不保证按照指定它们的先后顺序执行）

XHTML：
可扩展超文本标记语言，是将HTML作为XML的应用而重新定义的一个标准
。
嵌入代码和外部文件

使用外部文件的优点：可维护性、可缓存、适应未来。
文档模式

混杂模式（quirks mode）、标准模式（standards mode）、准标准模式（almost standards mode）

第三章 基本概念

严格模式(strict mode)：
若要在整个脚本中启用，可在顶部添加如下代码：
"use strict";
在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：

function doSomething() {
"use strict";
//函数体
}

变量

var 变量名
使用var（关键字）+变量名(标识符)的方式在function外部声明，即为全局变量，否则在function声明的是局部变量
const声明只读常量

数据类型

简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String
复杂数据类型：Object

typeof操作符

检测给定变量的数据类型

"undefined"——如果这个值未定义

"boolean"——如果这个值是布尔值

"string"——如果这个值是字符串

"number"——如果这个值是数值

"object"——如果这个值是对象或null

"function"——如果这个值是函数

Undefined类型

只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化

Null类型

只有一个值，null。null表示一个空对象指针。undefined值派生自null值
alert(null == undefined);    //true

Boolean类型

只有两个字面值：true和false（小写）
要将一个值转换为其对应Boolean值，可以调用转型函数Boolean（）
各种数据类型及其转换规则（P26）

Number类型

最基本的数值字面量格式是十进制，十进制整数可以直接在代码中输入

八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7），如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析
var octalNum1 = 070     //八进制的56
var octalNum2 = 079     //无效的八进制数值——解析为79
八进制字面量在严格模式下是无效的

十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F），字母A~F可以小写
在进行算术计算时，所有八进制和十六进制表示的数值最终都将被转换成十进制数值。

浮点数值：
该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。

e表示法（科学技术法）：
用e表示法表示的数值等于e前面的数值乘以10的指数次幂。

ECMAScript中e表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母E，后面是10的幂中的指数：
var floatNum = 3.125e7；   //等于31250000

NaN：
即非数值，是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况。

数值转换：
有3个函数可以把非数值转换为数值：
Number()：转型函数，可以用于任何数据类型。转换规则（P30）
parseInt()、parseFloat()：专门用于把字符串转换成数值

String类型

用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可由双引号（""）或单引号('')表示。

字符字面量：

\n  换行，\t  制表，\b  退格，\r  回车，\f  进纸，\\  斜杠，\' 单引号（'），\"  双引号（"），\xnn  以十六进制代码nn表示的一个字符（其中n为0~F），\unnnn  以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）。

字符串的特点：一旦创建，它们的值就不能改变。

转换为字符串：
toString()，在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String（）（转换规则P34）

Object类型

constructor：保存着用于创建当前对象的函数。
hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定。

isPrototypeof(object)：用于检查传入的对象是否是当前对象的原型。

propertyIsEnumerable(propertName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty（）方法一样，作为参数的属性名必须以字符串形式指定。

toLocaleString()：返回对象的字符串表示，该字符串、数值或布尔值表示。通常与toString（）方法的返回值相同。

操作符

一元操作符：递增递减，前置型和后置型

位操作符：按内存中表示数值的位来操作数值。按位取非（~）按位与（&）按位或（|）按位异或（^）左移（<<）不会影响符号位，有符号右移（>>）无符号右移（>>>）。

布尔操作符：逻辑非（!）同时使用两个逻辑非会模拟Boolean()转型函数，逻辑与（&&）短路逻辑，逻辑或（||）短路逻辑。

乘性操作符：乘法（*），除法（/）。Infinity除Infinity结果是NAN，有一个操作数是NAN结果是NAN

加性操作符：加法（+），减法（-）

关系操作符：小于（<）大于（>）小于等于（<=），大于等于（>=）用于两个值的比较，返回布尔值。注意字符串比较“23”<“3”。

相等操作符：相等（==）不相等（!==）。全等（===）两个操作数未经转换前就相等。不全等（!==）未经转换前就不相等。

条件操作符：variable = boolean_expression ? true_value : false_value;

赋值操作符：乘/赋值（*=）除/赋值（/=）模/赋值（%=）左移/赋值（<<=）有符号右移/赋值（>>=）无符号右移/赋值（>>>=）。

逗号操作符：用于声明多个变量；用于赋值（总是会返回表达式最后一项）。

语句

if语句：条件判断

while语句：只要指定条件为
true，循环就可以一直执行代码

switch语句：用于基于不同的条件来执行不同的动作

do-while语句：后测试循环语句，是 while 循环的变体。该循环会执行一次代码块，在检查条件是否为真之前，然后如果条件为真的话，就会重复这个循环

for语句：前测试循环语句，语句循环遍历对象的属性

for-in语句：迭代语句，用来枚举对象属性

label语句：在代码中添加标签

break语句：在循环中精确地控制代码的执行，会立即退出循环，强制继续执行循环后面的语句

continue语句：在循环中精确地控制代码的执行，立即退出循环，退出后会从循环的顶部继续执行

with语句：前测试循环语句

函数

使用function关键字声明，通过其函数名调用。ECMAScript中的函数在定义时不必指定是否返回值，实际上，任何函数在任何时候都可以通过return语句来返回值。在执行完return语句后停止并立即退出。未指定返回值的函数返回的是一个特殊的undefined值

理解参数

ECMAScript中没有函数签名的概念，因为其函数参数是以一个包含多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。

没有重载

由于不存在函数签名的特性，ECMAScript函数不能重载

第四章 变量，作用域和内存问题

基本类型和引用类型的值
ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。
基本类型值指的是简单的数据段，引用类型值指那些可能由多个值构成的对象。

动态的属性

基本类型值和引用类型值的定义是类似的：创建一个变量并给该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则不同，对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。不过不能给基本类型的值添加属性。

复制变量值

基本类型的值的复制：在变量对象上创建一个新值，然后把这个值复制到为新变量分配的位置上
引用类型的值的复制：在变量对象上创建一个新值，然后把这个值复制到为新变量分配的位置上，但是这个值的副本是一个指针（指向存储在堆中的一个对象），复制操作结束后，两个变量实际上引用同一个对象，改变其中一个变量，就会改变另一个变量

传递参数

ECMAScript中所有函数的参数都是按值传递。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

检测类型

typeof操作符
instanceof操作符：result = variable instanceof constructor

执行环境及作用域

执行环境（环境）:
定义了变量和函数有权访问其他数据。
每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

全局执行环境是最外围的一个执行环境，在Web浏览器中被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的
。
某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数的定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器时才会被销毁）。

每个函数都有自己的执行环境，当执行流进入一个函数时，会把当前函数环境推入一个环境栈，而函数执行后，栈将其环境弹出，把控制权交给之前的执行环境。
当代码在一个环境中执行时，会创建变量对象的一个作用域链，以保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在环境的变量对象。如果是函数环境，将其活动对象作为变量对象，活动对象最开始只有一个变量arguments对象（全局环境不存在）。
作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，一直延续到全局执行环境，全局环境的变量对象始终都是作用域链的最后一个对象。

识符解析是沿着作用域链一级一级地搜索标识符的过程，始终从作用域链的前端开始，逐级回溯，直到找到标识符为止。

一般一个函数的作用域链包含两个对象：它自己的变量对象（arguments对象）和全局环境的变量对象。
内部环境可以通过作用域链访问所有外部环境，外部环境不能访问内部环境中的任何变量和函数，每个环境都可以向上搜索作用域链，以查询函数名和变量。

延长作用域链

虽然执行环境只有两种：全局和局部（函数），但是可以通过在作用域前端临时增加一个变量对象，该变量对象会再代码执行后被移除

有两种语句可以加临时变量对象：
try-catch的catch块（创建一个新的变量对象）和with语句（将指定的对象添加到作用域链中）

没有块级作用域

JavaScript没有块级作用域

for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。

声明变量

使用var声明变量会自动被添加到最近的执行环境中，如果初始化没有var声明，该变量会被添加到全局环境

查询标识符

查询标识符从搜索开始，搜索从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果局部环境找了，搜索停止；否则，沿着作用域链向上搜索，直到搜索到全局环境中的变量对象，如果还没有找到则意味变量没有声明
如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，全局环境中的变量使用window.color访问全局color标识符

垃圾收集

JavaScript具有自动的垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，原理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性的执行这一操作。

标记清除

JavaScript中最常用的垃圾收集方式。
当变量进入环境（如在环境中声明一个变量）时，就将这个变量标记为“进入环境”，逻辑上来说，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，当变量离开环境时，则将其标记为“离开环境”。
垃圾收集器会在运行时给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记，而此后再被标记的变量就是要回收的变量。

引用计数

引用计数是跟踪记录每个被引用的次数，当声明一个变量并将引用类型值赋给变量后，引用次数+1，如果引用的变量取得了另一个值，引用次数-1，当引用次数变成0时，则说明没有办法再访问这个值了，就可以将其占用的内存空间回收回来，在垃圾收集器下一次运行时释放引用次数为0的值所占用的内存。

循环引用：对象A包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

存在循环引用现象时，“引用计数”算法会导致问题。
未为了避免类似的循环引用的问题，最好是在不使用它们的时候手工断开原生JavaScript对象与DOM元素之间的连接。

性能问题

确定垃圾收集的时间间隔是一个非常重要的问题
如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和数组元素的临界值就会加倍；如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。

管理内存

解除引用：一旦数据不再有用，最好通过将其值设置为null来释放其引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量对在它们离开执行环境时自动被解除引用。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

第五章 引用类型

object类型

创建方式：
①使用new操作符后跟object构造函数：

var person = new Object();

person.name = "Nicholas";

person.age = 29;

②使用对象字面量表示法：

var person = {

name : "Nicholas";

age : 29;

};

访问方式 ：一种为 对象点属性名称   “person.name”   或者使用中括号  “person["name"]” 使用中括号必须用引号括起来  或者括号内使用的是变量  例如：var b="name"；  person[b] 

Array类型

ECMAScript数组的每一项可以保存任何类型的数据。
创建方式：

①使用Array构造函数：
var colors = new Array();
var colors = new Array(20);//length为20的数组

②数组字面量表示法：
数组字面量由一堆包含数组项的方括号表示，多个数组项之间以逗号隔开。
var colors = ["red","blue","green"];//创建包含3项的数组；
var name = [ ]；//创建一个空数组

检测数组

①instanceof操作符；②Array.isArray()方法

转换方法

valueOf（）返回数组本身
toString（）返回一个由数组中每个值的数组形式组成的以逗号相隔的字符串
toLocalString（）：威力取得每一项的值，每次调用每一项的toLocalString

栈方法

栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部。

push（）方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。

pop（）方法从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

队列方法

访问规则FIFO（First-In-First-Out，先进先出）

push（）在数组末尾添加一项并返回长度

shift（）移除数组中的第一个项并返回该项，同时将数组长度减1

重排序方法

sort（）排序，按照字符串比较方式来排序

reverse（）倒序

操作方法

concat（）；slice（）；splice（）

位置方法

①indexOf （）②lastIndexOf（）

迭代方法

some（）：对数组每个元素运行指定函数 ，如果数组中某个元素对应函数都返回true 则此方法返回true  否则返回false

every（）：对数组每个元素运行指定函数 ，如果数组中每个元素对应函数都返回true 则此方法返回true  否则返回false

filter（）：对数组每个元素运行指定函数  返回 函数返回为true的元素 组成一个新的数组

map（）：对数组每个元素运行指定函数 返回 函数运行结果的数组

forEach（）：对数组每个元素运行指定函数  无返回值

归并方式

reduce()和 reduceRigth() 方法 

顺序执行给定函数和逆序执行给定函数 最终遍历整个数组 的子项执行指定的函数   ，function中第一个参数为 数组第一个元素的值    第二个为当前的元素值，第三个为元素的索引   第四个为数组对象

Date类型

要一个日期对象，使用new操作符和Date构造函数
var date = new Date();

Date.parse();接收指定格式的日期字符串转化成 毫秒数  如果传入的字符串不能表示日期，则此方法返回NaN    ，当在Date对象的构造函数中传入字符串时  js后台解析也是通过调用Date.parse()方法来获取毫秒数

 Date.UTC()方法  也是返回表示指定日期的毫秒数  而它的参数 分别是年份 基于0的月份（一月是0，二月是1。。。。  ），月的天数（1-31）、小时（0-23）、分（0-59）、秒（0-59），毫秒（0-99）    而这些参数中只有 年份和月份 是必要参数，其他不传，都会默认为0
 
Date.now()方法 返回当前时间的毫秒值  

RegExp类型

正则表达式

var expression = /pattern/flags
模式parttern:可以是任何复杂简单的正则表达式，包括限定符、字符、分组等
标志flags：g:全局模式（返回所有匹配项）；i:忽略大小写；m:多行模式

RegExp构造函数

var expssion = new RegExp(pattern, flags);
var reg = new RegExp(“[bc]at”,”ig”);
=>同 var reg = /[bc]at/gi
对于构造函数模式，注意需要对特殊字符进行双重转义

RegExp实例属性

global：布尔值，表示是否设置了g标志

ignoreCase：布尔值，表示是否设置了i标志

lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起

multiline：布尔值，表示是否设置了m标志

source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回

RegExp实例方法

exec() 方法  捕获 匹配项的字符串  返回被捕获字符串的数组    但不同于普通数组    额外提供了 index和input属性    index  表示匹配的索引位置，input 表示应用正则表达式的字符串

test() 方法    返回布尔值    只验证是否包含 符合规定的字符串对象   包含返回true  否则返回false
 利用JS 正则表达式验证邮箱格式
 
Function类型

函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

函数通常是使用函数声明语法定义的：

function sum(num1,num2){
    return num1 + num2;
}

解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。
使用Function构造函数

Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数

var sum = new Function("num1","num2","return num1 + num2"); // 不推荐

从技术角度讲，这是一个函数表达式。但是，我们不推荐使用这种方式来定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。

注：使用不带圆括号的函数名是访问函数指针，而非调用函数。

因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。

函数内部属性

在函数内部，有两个特殊的对象：arguments和this。其中arguments是一个类数组对象，包含着传入函数中的所有参数。this引用的是函数据以执行的环境对象--或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）

callee

虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。当函数在严格模式下运行时，访问arguments.callee会导致错误。

caller

这个属性中保存着调用当前函数的函数的引用，如果实在全局作用域中调用当前函数，它的值为null。

函数的属性和方法

属性：每个函数都包含两个属性:length和prototype
length属性表示函数希望接收的命名参数的个数；
prototype是保存它们所有实例方法的真正所在。prototype属性是不可枚举的，因此使用for-in无法实现；

方法：每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。

call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同，传递给函数的参数必须逐个列举出来；

ES5定义了bind()方法会创建个函数的实例，其this值会被绑定到传给bind()函数的值；

基本包装类型

每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。
引用类型和基本包装类型的主要区别就是对象的生存期。
使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中；
自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行的时候为基本类型值添加属性和方法；
可以显式的调用Boolean、Number和String来创建基本包装类型的对象：
这种做法很容易分不清处理基本类型还是引用类型。对基本包装类型的实例调用typeof会返回"object"，而且所有基本包装类型的对象都会被转换为布尔值true；
使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。

Boolean类型


Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()方法，返回字符串"true"和"false"；
使用instanceof()操作符测试Boolean对象会返回true；
布尔表达式中的所有对象都会被转换为true；
建议永远都不要使用Boolean对象

Number类型

valueOf()：返回对象表示的基本类型的数值；

toString()：返回字符串形式的数值，可以为其传递一个表示基数的参数，告诉它返回几进制数值的字符串形式；

toFixed()：会按照指定的小数位返回数值的字符串表示，这个方法很适合处理货币值；

toExponential()：该方法返回以指数表示法（也称e表示法）表示的数值的字符串形式；

toPrecision()：这个方法会根据要处理的数值决定到底是调用toFixed()还是toExponential()，这三个方法都可以通过向上向下舍入，做到以最准确的形式来表示带有正确小数位的值。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）

String类型

String类型的每一个实例都有一个length属性，表示字符串中包含多少个字符。即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。

字符方法

两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。这两个方法都接收一个参数，即基于0的字符位置

charAt()：这个方法以单字符串的形式返回给定位置的那个字符；

charCodeAt()：这个方法以字符编码的形式返回给定位置的那个字符；

ES5中还定义了，可以使用方括号加数字索引（[1]）来访问字符串中特定位置;

字符串操作方法

concat()：用于将一个或多个字符串拼接起来，返回拼接得到的新字符串，它不会影响原字符串；

ES还提供了3个基于子字符串创建新字符串的方法：slice()、substr()和substring()。
这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数，第一个参数指定字符串的开始位置；

slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置；

substr()的第二个参数指定的是返回的字符个数；
这三个方法都不会影响原字符串

在给这些方法传递负值的情况下，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将第二个参数转换为0，substring()方法会把所有负值参数都转换为0；

字符串位置方法

从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。

这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）

indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串；

这两个方法都可以接收第二个参数，表示从字符串中的哪个位置开始搜索；

trim()：ES5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。由于trim()返回的是字符串的副本，所以不影响原始字符串

字符串大小写转换方法

ECMAScript设计大小写转换的方法有四个toLowerCase、toLocaleLowerCase()、toUpperCase()和toLacleUpperCase()。其中toLowerCase和toUpperCase()是两个经典方法，而toLocaleLowerCase()和toLacleUpperCase()方法则是针对特定地区的实现。

字符串的模式匹配方法

match()：在字符串上调用这个方法本质上与调用RegExp的exec()的方法相同。它只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象；

search()：这个方法的唯一参数与match()方法的参数相同。这个方法返回字符串中第一个匹配项的索引，如果没有找到匹配项则返回-1，而且search()方法始终是从字符串开通向后查找模式；

replace()：这个方法接收两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。

如果第一个参数是字符串，那么只会替换第一个子字符串，想要替换所有的子字符串唯一的方法就是提供一个正则表达式，而且要指定全局（g）标志；

这个方法的第二个参数也可以使一个函数。在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串；
这个方法不会影响原字符串；

split()：这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中，分隔符可以是字符串，也可以是一个RegExp对象。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。

localeCompare()
这个方法比较两个字符串，并返回下列值中的一个：
如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多情况下是-1）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多情况下是1）；

formCharCode()
String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。

单体内置对象

由ECMAScript实现提供的，不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了
Global对象
所有在全局作用域中定义的属性和函数，都是Global对象的属性。
URI编码

Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发送给浏览器

encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码；

它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码；

decodeURI()只能对使用encodeURI()替换的字符进行解码，同样的decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码；

eval()方法

这个方法就像一个完整的ECMAScript解析器。
它只接收一个参数，即要执行的ECMAScript字符串；
通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链；

在eval()中创建的任何变量都不会被提升
严格模式下，在外部访问不到eval()中创建的任何变量或函数

Global对象的属性

特殊的值undefined、NaN以及Infinity都是Global对象的属性；
所有原生引用类型的构造函数，也都是Global对象的属性；

ES5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误；

window对象

Web浏览器将这个全局对象作为window对象的一部分加以实现。在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。
在没有给函数明确指定this值的情况下，this值等于Global对象

Math对象

ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象

min()和max()

这两个方法用于确定一组数值中的最小值和最大值。这两个方法都可以接受人一多个数值参数；

要找到数组中的最大最小值，可以使用：Math.max.apply(Math,arr)

舍入方法

Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；

Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；

Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数；

random()方法

Math.random()方法返回大于等于0小于1的一个随机数
可以利用这个方法从某个整数范围内随机选择一个值
值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)

第六章 面相对象的程序设计

 ECMA-262 把对象定义为 “无序属性的集合，其属性可以包含基本值，对象或者函数” 
 
理解对象

属性类型
①数据属性；②访问器属性。

数据属性：
[[Configurable]]:表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性。
[[Enumerable]]表示能否通过for-in循环返回属性。
[[Writable]] 表示能否修改属性的值。
[[Value]] 包含这个属性的数据值。读取属性值时，从这个位置读，写入属性值的时候，把新值保存在这个位置 。
要修改属性的默认的特性，必须使用ECMAScript 5的Object.defineProperty（）方法，这个方法接收三个参数，属性所在的对象、属性的名字和一个描述符对象。描述符的对象属性必须是configurable 、enumerable 、writable、value。设置其中的一个或多个值，可以修改对应的特性值。

访问器属性：
访问器属性不包含数据值，只含一对getter和setter函数； 
在读取访问器属性时，会调用getter函数，负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值， 
访问器属性有四个特性：
[[Configurable]]:表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性。
[[Enumerable]]表示能否通过for-in循环返回属性。
[[Get]] 读取属性时调用的函数。
[[Set]] 写入属性时调用的函数。
访问器属性不能直接定义，必须使用Object.defineProperty()来定义。

定义多个属性
Object.defineProperties（）方法，可以通过描述符一次定义多个属性，这个方法接收两个对象参数：第一个为要添加和修改其属性的对象，第二个对象与第一个对象中要添加或修改的属性一一对应 

读取属性的特性

使用ECMAScript5的Object.getOwnPropertyDescriptor（）方法，可以取得给定属性的描述符。这个方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumberable、get和set；如果是数据属性，这个对象的属性有configurable、enumberable、writable和value。

创建对象

工厂模式

解决了重复代码的问题，但是没有解决对象的识别问题（即知道一个对象的类型）

构造函数模式

构造函数应以一个大写字母开头，非构造函数以小写字母开头

new调用构造函数会经历一下4个步骤
1.创建一个新对象
2.将构造函数的作用域赋给新对象（因此this就指向这个新对象）
3.执行构造函数中的代码（为这个新对象添加属性）
4.返回新对象 

构造函数当做函数
：任何函数，只要能通过new来调用，就可以把它作为构造函数
构造器函数缺点：：每个方法都要在每个实例上重新创建一遍 

可以把函数定义转移到构造函数外部来解决这个问题。但是会出现新的问题，全局函数只能被某个函数调用，如果有很多方法就要定义很多全局函数，，没有封装性可言，那就引出了原型模式

原型模式 

每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用于是包含可以由特定类型的所有实例共享的属性和方法；可以让所有对象实例共享它所包含的属性和方法；不用再构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中

原型与in操作符 

两种方法使用in操作符：单独使用和for-in循环中使用。单独使用时，in会在通过对象能访问给定属性时返回true，无论在实例中还是在原型中（可以和hasOwnProperty结合使用，确定属性在对象还是原型）

在使用for-in 循环时，返回的是所有能通过对象访问的、可枚举（enumerated）属性，其中既包括实例中的属性，也包括存在于原型中的属性 。屏蔽了原型中不可枚举的属性（即将[[Enumerable]]标记为false的属性）的实例属性也会在for-in循环中返回。
获取所有的实例属性，无论是否可枚举，都可以使用Object.getOwnPropertyNames()方法。

原型的动态性 

由于在原型查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例上反映出来，即使先创建了实例后修改原型也是如此

重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。

动态原型模式

动态原型创建对象，把所有信息都封装在构造函数中，通过在构造函数重初始化，原型，又保持了同时使用构造函数和原型的优点。（可以进行检测）

unction Person(name, age, job) {
    //属性
    this.name = name;
    this.age = age;
    this.job = job;
    // 方法，if语句检查初始化之后应该存在的属性偶方法
    if(typeof this.sayName != 'function') { //sayName不存在是，才会添加
        Person.prototyep.sayName =  function(){
            console.log(this.name);
        }
    }
}
var friend = new Person('Nicholas', 29, 'Software Engineer');
friend.sayName();

使用动态原型模式时，不能使用对象字面量重写原型

寄生构造函数模式

基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象
可以在特殊的情况下用来为对象创建构造函数
返回的对象与构造函数或者与构造函数的原型属性之间没有关系

稳妥构造函数模式

没有公共属性，而且其他方法也不引用this对象 ，稳妥对象适合在一些安全的环境中使用（这些环境会禁用this和new）
继承
一个对象能够访问另一个对象的属性，同时这个对象还能添加自己的新的属性或是覆盖可访问的另一个对象的属性，这种方式叫继承
JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别

原型链

基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。

原型式继承

可以在预先定义构造函数的情况下实现继承，本质是执行给定对象的浅复制

object.create()函数是javascript提供给我们的创建对象时，设置内部[[proto]]的属性API，通过修改[[ptoto]]属性的值，就可以决定对象所继承的对象，可以实现我们使用想用的方式实现继承。

该种继承接收两个参数：
1.创建对象想要的原型对象
2.属性描述对象
会返回一个对象
var x = { 

    name: 'tom',
    sayName: function() {
        console.log(this.name)
    }
}
var y = Object.create(x, {

    name: {
        configurable: true,
        enumerable: true,
        value: 'Tony',
        writable: true
    }
})
y.sayName() // 'Tony'

寄生式继承

与原型式继承类似，基于某个对象或者某些信息创建对象，然后增强对象，最后返回对象
function object(o){
 　　function a(){
 　　}
　　a.prototype=o;
　　 return new a();
 };
function createAnother(original){
    var clone = object(original); // 通过调用函数创建一个新对象
    clone.sayHi = function(){ //以某种方式增强真个对象
        console.log("hi");
    }
    return clone; //返回这个对象
}
var person={
            name:"Nicholas",
            friends:["Shelby","Court","Van"]
       }
 var obj = createAnother(person);
 obj.sayHi(); // hi
 
寄生组合式继承

通过借用构造函数来继承属性，通过原型链的混合形式来继承方法（可以接觉组合继承调用两次的缺点）

1.创建超类型的一个副本
2.为创建的副本添加construct属性，弥补因重写原型而失去默认的constructor
3.将新创建的对象赋值给子类型的原型

第七章 函数表达式

递归

递归函数就是在一个函数中通过名字调用自身
function factorial(n) {

      if (n <= 1) { 
	return 1; 
      } else { 
	return n * factorial(n - 1) 
      } 
} 
factorial(5);    //120


递归函数的优化
function factorial(num) {   

       if (num<=1) { 
       	  return 1;    
       } else {
           return num * arguments.callee(num-1);    
       }
}
factorial(5);    //120

arguments.callee是一个指向正在执行的函数的指针。

闭包
function func() { 

      var num = 1;   
      num++; 
      console.log(num);
}     

func(); 	//2

func();		//2

通常情况下，函数中声明的局部变量，会在函数执行完毕后被销毁

闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数
function func() { 

     var num = 1; 
     return function(){
           console.log(num++)
     }; 
}     
var foo=func(); 

foo();//1

foo();//2  
func = null;//垃圾回收

闭包的特点：

1. 函数中嵌套函数。
2. 嵌套的函数可以使用外层函数作用中的变量和参数。
3. 参数和变量不会被垃圾回收机制回收。
4. 
闭包的优点:

1. 局部变量长期驻扎在内存中（其实所有的特点都是由长期驻扎实现的）。
2. 避免全局变量的污染。
3. 私有成员的存在。
总结：闭包其实就是在函数执行完毕后，变量依然存在于内存没有被销毁的一种现象。

关于this对象

this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用是，this等于那个对象。

模仿块级作用域

function outNum() {

	for(var i=0;i<10;i++){ 
     	      console.log(i);	
}	
console.log(i);  //10
}
JavaScript没有块级作用域。

模仿块级作用域形式

(function(){   
 	//块级作用域
})();
首先定义并立即调用一个匿名函数。将函数声明包含在圆括号中，表示它实际上是一个函数表达式。最后的原括号表示立即调用这个函数。

私有变量

任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量
私有变量包括函数的参数、局部变量和在函数内部定义的其他函数
有权访问私有变量的方法叫做特权方法

function MyObject(){

    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //特权方法
    this.publicMethod = function (){
        privateVariable++;
        return privateFunction();
    };
}

静态私有变量

(function(){

    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //构造函数（全局变量）
    MyObject = function(){
    };
    //公有/特权方法
    MyObject.prototype.publicMethod = function(){
        privateVariable++;
        return privateFunction();
    };
})();

模块模式

1.单例对象
var singleton = {

    name : value,
    method : function () {
        //这里是方法的代码
    }
};
2.模块模式通过为单例添加私有变量和特权方法能够使其得到增强
var singleton = function(){

    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //特权/公有方法和属性
    return {
        publicProperty: true,
        publicMethod : function(){        
            privateVariable++;
            return privateFunction();
        }    
    };
}();

增强的模块模式


var singleton = function(){

    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //创建对象
    var object = new CustomType();
    //添加特权/公有属性和方法
    object.publicProperty = true;
    object.publicMethod = function(){
        privateVariable++;
        return privateFunction();
    };
    //返回这个对象
    return object;
}();

可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。